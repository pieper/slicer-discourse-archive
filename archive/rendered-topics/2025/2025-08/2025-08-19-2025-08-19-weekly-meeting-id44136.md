# 2025.08.19 Weekly Meeting

**Topic ID**: 44136
**Date**: 2025-08-19
**URL**: https://discourse.slicer.org/t/2025-08-19-weekly-meeting/44136

---

## Post #1 by @jcfr (2025-08-19 13:21 UTC)

<p>This morning, we will be having our next weekly hangout at <strong>10:00 AM ET until 11:00 AM ET.</strong></p>
<p>Anyone is welcome to join at this link: <a href="https://bit.ly/slicer-googlemeet-hosted-by-kitware">https://bit.ly/slicer-googlemeet-hosted-by-kitware</a></p>
<hr>
<div class="discourse-post-event" data-start="2025-08-19 10:00" data-status="public" data-name="Weekly Meeting" data-url="https://bit.ly/slicer-googlemeet-hosted-by-kitware" data-timezone="America/New_York" data-allowed-groups="trust_level_0"></div>
<p><strong>Agenda:</strong></p>
<ul>
<li>Release status</li>
<li>Outstanding pull requests</li>
</ul>
<p>Please post to this thread to put a topic on the agenda!  We will try to prioritize agenda items during the meeting.</p>
<hr>
<p>Thanks<br>
Sam and J-Christophe</p>

---

## Post #2 by @jcfr (2025-08-20 04:06 UTC)

<h2><a name="p-127746-meeting-notes-1" class="anchor" href="#p-127746-meeting-notes-1" aria-label="Heading link"></a>Meeting Notes</h2>
<h3><a name="p-127746-slicer-trame-2" class="anchor" href="#p-127746-slicer-trame-2" aria-label="Heading link"></a>Slicer-trame</h3>
<p><strong>VTK Python Packaging Limitation</strong><br>
The current VTK Python package on PyPI is monolithic and does not support the installation of additional VTK-based modules (e.g., <code>vtk-addons</code>, <code>vtk-webcore</code>) that could extend the <code>vtk</code> namespace. This limits modular packaging and downstream development, such as that needed for <code>slicer-trame</code>.</p>
<p><strong>Next Steps</strong><br>
<a class="mention" href="/u/thibault_pelletier">@Thibault_Pelletier</a> will investigate how to restructure the VTK packaging infrastructure to support namespace extension, in a way similar to how the <code>trame</code> namespace is currently extended.</p>
<p><strong>Relevant Resources</strong></p>
<ul>
<li>VTK discourse discussion: <a href="https://discourse.vtk.org/t/rfc-toward-supporting-distribution-of-vtk-based-modules-on-pypi/4873/10">Toward supporting distribution of VTK-based modules on PyPI</a></li>
<li>Python packaging guidance: <a href="https://packaging.python.org/en/latest/guides/packaging-namespace-packages/#creating-a-namespace-package">Creating a namespace package</a></li>
</ul>
<hr>
<h3><a name="p-127746-dicom-anonymization-3" class="anchor" href="#p-127746-dicom-anonymization-3" aria-label="Heading link"></a>DICOM Anonymization</h3>
<p><strong>Overview</strong><br>
The team discussed various tools for DICOM anonymization, especially in the context of IDC workflows and hospital data sharing.</p>
<p><strong>Feedback from <a class="mention" href="/u/lassoan">@lassoan</a></strong></p>
<ul>
<li>
<p><a href="https://github.com/KitwareMedical/dicom-anonymizer"><code>KitwareMedical/dicom-anonymizer</code></a> was tested but lacks support for advanced features, such as:</p>
<ul>
<li>Preserving specific private tags (<a href="https://github.com/KitwareMedical/dicom-anonymizer/issues/96">issue #96</a>)</li>
</ul>
</li>
<li>
<p>Instead, PyDICOM’s built-in anonymization tools were used.</p>
</li>
<li>
<p>The most advanced tool identified was DCIA, which includes ~1000 rules tailored for private tag handling.</p>
</li>
</ul>
<p><strong>Feedback from <a class="mention" href="/u/pieper">@pieper</a></strong></p>
<ul>
<li>There’s a need to anonymize DICOM consistently across multiple series (e.g., keeping the same anonymized birthdate).</li>
<li>Steve developed a JavaScript-based tool using <code>DCMJS</code> and <a href="https://github.com/bebbi/dicom-curate"><code>dicom-curate</code></a>, especially useful in contexts where software installation is not feasible.</li>
</ul>
<p><strong>Additional Resource</strong></p>
<ul>
<li>Encapsulating STL data in DICOM format: <a href="https://dicom.innolitics.com/ciods/encapsulated-stl">https://dicom.innolitics.com/ciods/encapsulated-stl</a></li>
</ul>
<hr>
<h3><a name="p-127746-viewnode-renderwindow-in-the-context-of-segmenteditor-refactoring-4" class="anchor" href="#p-127746-viewnode-renderwindow-in-the-context-of-segmenteditor-refactoring-4" aria-label="Heading link"></a>ViewNode &amp; RenderWindow in the Context of SegmentEditor Refactoring</h3>
<p><strong>Background</strong><br>
The discussion centered on improving the Segment Editor’s integration with the rendering system without depending on the Qt layer.</p>
<p><strong>Key Points</strong></p>
<ul>
<li>
<p>Discussed <a href="https://github.com/Slicer/Slicer/pull/8604">PR #8604</a>, which addresses cleaner access to rendering components via the MRML scene.</p>
</li>
<li>
<p>It was agreed that:</p>
<ul>
<li>A dedicated displayable manager for the Segment Editor should be added.</li>
<li>Rendering-specific properties (e.g., <code>vtkRenderer</code>) should not be stored directly in view nodes.</li>
</ul>
</li>
</ul>
<p><strong>Planned Enhancements</strong></p>
<ul>
<li>Introduce a new helper method:<br>
<code>vtkMRMLApplicationLogic::GetViewDisplayableManagerByClassName()</code></li>
</ul>
<p><strong>Relevant Usage Examples</strong></p>
<ul>
<li><a href="https://github.com/Slicer/Slicer/blob/8a96c0c2b94eb6088a9520c198e4325d9965fdcf/Modules/Loadable/Segmentations/Widgets/qMRMLSegmentEditorWidget.cxx#L2852"><code>qMRMLSegmentEditorWidget.cxx#L2852</code></a></li>
<li><a href="https://github.com/Slicer/Slicer/blob/8a96c0c2b94eb6088a9520c198e4325d9965fdcf/Modules/Loadable/Segmentations/EditorEffects/Python/SegmentEditorEffects/SegmentEditorDrawEffect.py#L59"><code>SegmentEditorDrawEffect.py#L59</code></a></li>
<li><a href="https://github.com/Slicer/Slicer/blob/8a96c0c2b94eb6088a9520c198e4325d9965fdcf/Modules/Loadable/Segmentations/EditorEffects/qSlicerSegmentEditorAbstractEffect.cxx#L288"><code>qSlicerSegmentEditorAbstractEffect.cxx#L288</code></a></li>
</ul>
<p><strong>Markup Integration</strong></p>
<ul>
<li>Plan to refactor the <em>Scissors</em> effect to use <em>Closed Curve Markups</em>.</li>
<li>Effects should be able to query which view nodes are currently mapped in the layout to determine relevant display contexts.</li>
</ul>

---
