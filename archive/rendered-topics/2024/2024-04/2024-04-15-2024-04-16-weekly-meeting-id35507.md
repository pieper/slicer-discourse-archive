---
topic_id: 35507
title: "2024 04 16 Weekly Meeting"
date: 2024-04-15
url: https://discourse.slicer.org/t/35507
---

# 2024.04.16 Weekly Meeting

**Topic ID**: 35507
**Date**: 2024-04-15
**URL**: https://discourse.slicer.org/t/2024-04-16-weekly-meeting/35507

---

## Post #1 by @Sam_Horvath (2024-04-15 20:35 UTC)

<p>Tomorrow, we will be having our next weekly hangout at <strong>10:00 AM ET until 11:00 AM ET</strong> .</p>
<p>Anyone is welcome to join at this link: <a href="https://bit.ly/slicer-googlemeet-hosted-by-kitware">https://bit.ly/slicer-googlemeet-hosted-by-kitware</a></p>
<hr>
<div class="discourse-post-event" data-start="2024-04-16 10:00" data-status="public" data-name="Weekly Meeting" data-url="https://bit.ly/slicer-googlemeet-hosted-by-kitware" data-timezone="America/New_York" data-allowed-groups="trust_level_0"></div>
<p><strong>Agenda:</strong></p>
<p>Please post to this thread to put a topic on the agenda!  We will try to prioritize agenda items during the meeting.</p>
<hr>
<p>Thanks<br>
Sam and J-Christophe</p>

---

## Post #2 by @pieper (2024-04-15 21:38 UTC)

<p>I’d like to discuss updating ITK to get the fix for <a href="https://github.com/InsightSoftwareConsortium/ITK/issues/4109">ITK #4109</a>.</p>

---

## Post #3 by @allemangd (2024-04-16 13:59 UTC)

<p>I’d like to discuss my requirements.txt proposal for scripted modules</p>
<aside class="onebox githubissue" data-onebox-src="https://github.com/Slicer/Slicer/issues/7697">
  <header class="source">

      <a href="https://github.com/Slicer/Slicer/issues/7697" target="_blank" rel="noopener nofollow ugc">github.com/Slicer/Slicer</a>
  </header>

  <article class="onebox-body">
    <div class="github-row">
  <div class="github-icon-container" title="Issue">
	  <svg width="60" height="60" class="github-icon" viewBox="0 0 14 16" aria-hidden="true"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg>
  </div>

  <div class="github-info-container">
    <h4>
      <a href="https://github.com/Slicer/Slicer/issues/7697" target="_blank" rel="noopener nofollow ugc">Allow scripted modules to declare pip requirements and wrap pip dependencies.</a>
    </h4>

    <div class="github-info">
      <div class="date">
        opened <span class="discourse-local-date" data-format="ll" data-date="2024-04-15" data-time="14:35:24" data-timezone="UTC">02:35PM - 15 Apr 24 UTC</span>
      </div>


      <div class="user">
        <a href="https://github.com/allemangD" target="_blank" rel="noopener nofollow ugc">
          <img alt="allemangD" src="https://avatars.githubusercontent.com/u/10702931?v=4" class="onebox-avatar-inline" width="20" height="20">
          allemangD
        </a>
      </div>
    </div>

    <div class="labels">
        <span style="display:inline-block;margin-top:2px;background-color: #B8B8B8;padding: 2px;border-radius: 4px;color: #fff;margin-left: 3px;">
          make-simple-things-simple
        </span>
        <span style="display:inline-block;margin-top:2px;background-color: #B8B8B8;padding: 2px;border-radius: 4px;color: #fff;margin-left: 3px;">
          Domain: build-system
        </span>
    </div>
  </div>
</div>

  <div class="github-row">
    <p class="github-body-container">This is tightly related to #7171 and #6913, but since this is more an RFC for a <span class="show-more-container"><a href="" rel="noopener" class="show-more">…</a></span><span class="excerpt hidden">particular solution, so I'm creating a separate issue for discussion specifically on this proposal.

---

Install scripted modules python dependencies during module discovery to support new use cases:

Safely `import` pip-installed dependencies at the global level without `catch ImportError: slicer.util.pip_install(...)` wrappers.

Create scripted CLI modules which wrap python package [entrypoints](https://setuptools.pypa.io/en/latest/userguide/entry_point.html).

Supersede `slicer.util.pip_install` usage in scripted loadable modules to help prevent/debug environment breakage from incompatible dependencies.

Create scripted CLI modules implemented in multiple Python source files.

# Proposed solution

When scripted modules are discovered (ie. `$NAME.py` or `$NAME.xml` is discovered) check for a corresponding `$NAME-requirements.txt`. When the module is initialized (lazily), check the dependencies and install. Show a summary and confirmation dialog to the user, similar to `pip install` when `-y` is not given. If installation is rejected, do not load the module.

For an extension to install `$NAME-requirements.txt`, they should use the `RESOURCES` argument to `SlicerMacroBuildScriptedModule`. This requires the `$NAME-requirements.txt` appear, with that name, in the source tree so that "installing" a module from source via module search path will still discover the file.

`SlicerMacroBuildScriptedCLI` does not currently have a `RESOURCES` argument, so additionally: add `SCRIPTS` and `RESOURCES` arguments and update it to use `ctkMacroCompilePythonScript` in the same way as `SlicerMacroBuildScriptedModule`. If neither `RESOURCES` nor `SCRIPTS` are provided, automatically add `$NAME.py` and `$NAME.xml` to each, respectively, for backwards compatibility. 

Note - this also allows splitting CLI modules into multiple files and multiple scripts. Only the script with a matching `$NAME.xml` is discovered at runtime.

Add a convenience argument `ENTRYPOINT` to `slicerMacroBuildScriptedCLI` (with the same semantics as [setuptools console script entrypoints](https://setuptools.pypa.io/en/latest/userguide/entry_point.html#console-scripts)) which is mutually exclusive with `SCRIPTS`. If provided, at configure time, generate a `$NAME.py` which invokes the function identified by `ENTRYPOINT`.
## Examples

The current behavior would be unchanged:

```cmake
slicerMacroBuildScriptedCLI(
	NAME Foo
)

slicerMacroBuildScriptedModule(
	NAME Bar
	SCRIPTS ...
	RESOURCES ...
)
```

Now it would be possible to explicitly list the script and xml for `ScriptedCLI`, or to declare additional scripts/resources:

```cmake
slicerMacroBuildScriptedCLI(
	NAME Foo
	SCRIPTS Foo.py ...
	RESOURCES Foo.xml ...
)
```

Each module could declare a `requirements.txt` to be checked just before module initialization:

```cmake
slicerMacroBuildScriptedCLI(
	NAME Foo
	SCRIPTS Foo.py ...
	RESOURCES Foo.xml Foo-requirements.txt ...
)

slicerMacroBuildScriptedModule(
	NAME Bar
	SCRIPTS Bar.py ...
	RESOURCES Bar-requirements.txt ...
)
```

And the CLI module could wrap a pip-installed entrypoint:

```cmake
slicerMacroBuildScriptedCLI(
	NAME Baz
	ENTRYPOINT libbaz.run:main
	RESOURCES Baz.xml Baz-requirements.txt  # installs `libbaz`
)
```

# Alternatives considered

- Dependencies declared per-extension, rather than per-module.
- Dependencies declared in a `requirements.txt` which is renamed to `$NAME-requirements.txt`.
- Dependencies declared directly in CMake.
- `REQUIREMENTS_FILE` or `PIP_DEPENDENCIES` or similar dedicated CMake macro argument.

All these suffer issues when developers "install" modules by adding the source tree to Slicer module path. Placing the dependencies in a `$NAME-requirements.txt` forces them to be picked up at module discovery and ensures they are updated as the file is edited.

Even if an extension developer does not build the project with CMake, the requirements are sure to be handled for users when the project is built and published via CI. If the developer forgets to declare the requirements file in `RESOURCES`, there would be a clear import error in user logs that the required packages are missing.

- Include `pip_install` calls in the generated `$NAME.py` file for `ENTRYPOINT`.

This only supports the `ENTRYPOINT` mechanism. This invokes dependency resolution on every CLI _invocation_, not just on CLI instantiation. It is incompatible with installing modules from source via module path.

# Future Planning

## CLI module virtual environments

In the future if CLI modules get their own virtual environment, module initialization must create the virtual environment and install `$NAME-requirements.txt` to _that_ virtual environment, then launch `$NAME.py` in the same environment. Behavior would be the same with or without the `requirements.txt`.

## Slicer Constraints File

If a Slicer constraints file is provided to lock versions of built-in packages like `numpy`, `vtk`, `SimpleITK`, etc. it may be provided with `pip -r $NAME-requirements.txt -c path-to-slicer-constraints.txt`. Should not be done for CLI modules if they have their own virtual environments.

## Dependency resolution errors

Discover all _loadable_ module requirements.txt togethre and invoke pip once with all the requirements listed together? This would detect incompatibilities between modules and mitigate startup time cost - especially if using `uv`. Should not be done for _CLI_ modules if they have their own virtual environments. 

e.g. `uv install -r Foo-requirements.txt -r Bar-requirements.txt -c path-to-slicer-constraints.txt`; might detect an incompatibility between `Foo` and `Bar` dependencies. How should this error be handled? The user should have a means to downgrade or remove one or both of the infringing extensions.

## Deprecate `slicer.util.pip_install`

Once `requirements.txt` is deemed mature, we should show a deprecation warning on `slicer.util.pip_install` to encourage extension developers to migrate to this mechanism; else dependency resolution will not be useful.

# Questions

`ENTRYPOINT` would not be supported by install-from-source, since it depends on CMake configure time. Is this a problem?

Scripted Loadable modules are initialized during startup - this means _all_ scripted modules dependencies would be resolved at startup. Is this overhead significant? We could mitigate this by:

- using `uv` instead of `pip`
- collecting all requirements and installing them together with multiple `-r` arguments. (This would also identify incompatibilities between extensions' dependencies).
- doing a fast-check with `pip freeze` to avoid dependency resolution in the happy path when everything is already installed.

Should pip installation be done at _extension_ installation time? How would from-source modules be handled? How would extension installation time module discovery be handled?

Should `pyproject.toml` be involved in any way? How do we handle from-source installation and module discovery? `tomllib` is available to Python in 3.11, or [tomli](https://pypi.org/project/tomli/) for prior versions. Setuptools supports [dynamic dependencies](https://setuptools.pypa.io/en/latest/userguide/pyproject_config.html#dynamic-metadata), but this is a _beta_ feature.

This technically allows installing multiple `.xml` files in a single `slicerMacroBuildScriptedCLI` call. Should this be explictly forbidden? Should this be explicitly allowed? Should multiple `ENTRYPOINT` arguments be allowed?

---

I am working on a draft implementation of these changes but it is not yet complete. I invite comments and concerns in the meantime.

cc @jcfr @ebrahimebrahim</span></p>
  </div>

  </article>

  <div class="onebox-metadata">
    
    
  </div>

  <div style="clear: both"></div>
</aside>


---
